using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Plugin.Maui.SmartNavigation.SourceGenerators
{
    [Generator]
    public class AutoDependencies : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Get the compilation
            var compilationProvider = context.CompilationProvider;

            // Register the source output
            context.RegisterSourceOutput(compilationProvider, (spc, compilation) =>
            {
                StringBuilder lb = new StringBuilder();
                Log.Init(lb);

                try
                {
                    var assembly = compilation.Assembly;

                    Log.WriteLine($"Scanning assembly: {assembly.Name}");

                    var types = GetAllTypes(compilation.SourceModule.ContainingAssembly.GlobalNamespace);

                    var dependencies = InitialiseDependencies(types);

                    Log.WriteLine("Getting MauiProgram...");

                    var mauiProgramName = $"{assembly.Name}.MauiProgram";

                    Log.WriteLine($"Global namespace: {compilation.Assembly.GlobalNamespace.Name}");

                    var mauiProgram = compilation.GetTypeByMetadataName(mauiProgramName);

                    if (mauiProgram is null)
                    {
                        Log.WriteLine("MauiProgram not found");
                        return;
                    }

                    bool hasUseAutoDependenciesAttribute = mauiProgram.GetAttributes()
                        .Any(ad => ad.AttributeClass?.ToDisplayString() == "Plugin.Maui.SmartNavigation.Attributes.UseAutoDependenciesAttribute");

                    if (!hasUseAutoDependenciesAttribute)
                    {
                        Log.WriteLine("UseAutoDependenciesAttribute not found, skipping.");
                        return;
                    }

                    Log.WriteLine($"Found main method: {mauiProgram.Name}");

                    StringBuilder sourceBuilder = new StringBuilder();

                    sourceBuilder.Append($@"using Plugin.Maui.SmartNavigation;
using Microsoft.Maui.Hosting;

// ---------------
// <auto-generated>
//   Generated by the SmartNavigation Auto-registration module.
//   https://github.com/matt-goldman/Plugin.Maui.SmartNavigation
// </auto-generated>
// ---------------

namespace {mauiProgram.ContainingNamespace.ToDisplayString()};

public static class PageResolverExtensions
{{

    public static MauiAppBuilder UseAutodependencies(this MauiAppBuilder builder)
    {{
         var ViewModelMappings = new Dictionary<Type, Type>();

         // pages
");

                    // add page registrations
                    foreach (var page in dependencies["Pages"])
                    {
                        string lifetime = dependencies["ExplicitSingletons"].Contains(page) ? "Singleton" : "Transient";

                        sourceBuilder.AppendLine($"         builder.Services.Add{lifetime}<global::{page.ToDisplayString()}>();");
                    }

                    sourceBuilder.Append(@"

         // ViewModels
");

                    // add ViewModel registrations
                    foreach (var vm in dependencies["ViewModels"])
                    {
                        string lifetime = dependencies["ExplicitSingletons"].Contains(vm) ? "Singleton" : "Transient";

                        sourceBuilder.AppendLine($"         builder.Services.Add{lifetime}<global::{vm.ToDisplayString()}>();");
                    }

                    sourceBuilder.Append(@"

         // Services
");

                    // add Service registrations
                    foreach (var service in dependencies["Services"])
                    {
                        string lifetime = dependencies["ExplicitTransients"].Contains(service) ? "Transient" : "Singleton";

                        var abstraction = dependencies["Abstractions"].Where(a => a.Name == $"I{service.Name}").FirstOrDefault();

                        if (abstraction is null)
                        {
                            sourceBuilder.AppendLine($"         builder.Services.Add{lifetime}<global::{service.ToDisplayString()}>();");
                        }
                        else
                        {
                            string serviceInterface = service.ToDisplayString();
                            serviceInterface = serviceInterface.Replace(service.Name, $"I{service.Name}");

                            sourceBuilder.AppendLine($"         builder.Services.Add{lifetime}<global::{abstraction.ToDisplayString()}, global::{service.ToDisplayString()}>();");
                        }
                    }

                    sourceBuilder.Append(@"

         // ViewModel to Page mappings
");

                    var mappings = GetPageToViewModelMappings(dependencies);

                    foreach (var mapping in mappings)
                    {
                        sourceBuilder.AppendLine($"         ViewModelMappings.Add(typeof(global::{mapping.Key.ToDisplayString()}), typeof(global::{mapping.Value.ToDisplayString()}));");
                    }

                    sourceBuilder.Append(@"

         // Initialisation
");

                    sourceBuilder.AppendLine($"         builder.Services.UseSmartNavigation(ViewModelMappings);");

                    sourceBuilder.AppendLine($"         return builder;");

                    // close the partial method and class
                    sourceBuilder.Append(@"    }
}");

                    // generate the source file
                    spc.AddSource("PageResolverExtensions.g.cs", sourceBuilder.ToString());
                    Log.WriteLine($"Generated: PageResolverExtensions.g.cs");
                }
                catch (Exception ex)
                {
                    Log.WriteLine("[AutoDependencies Source Generator] Exception thrown: ");
                    Log.WriteLine($"{ex}");
                    Log.WriteLine($"{ex.StackTrace}");
                }
                finally
                {
                    Log.WriteLine("[AutoDependencies Source Generator] Finished.]");
                    Log.FlushLog();
                }
            });
        }

        private Dictionary<string, HashSet<ITypeSymbol>> InitialiseDependencies(IEnumerable<ITypeSymbol> types)
        {
            var comparer = SymbolEqualityComparer.Default;

            var dependencies = new Dictionary<string, HashSet<ITypeSymbol>>
            {
                { "Pages", new HashSet<ITypeSymbol>(comparer) },
                { "ViewModels", new HashSet<ITypeSymbol> (comparer) },
                { "Services", new HashSet<ITypeSymbol>(comparer) },
                { "Abstractions", new HashSet<ITypeSymbol>(comparer) },
                { "ExplicitSingletons", new HashSet<ITypeSymbol>(comparer) },
                { "ExplicitTransients", new HashSet<ITypeSymbol>(comparer) }
            };

            var ignoredTypes = new HashSet<ITypeSymbol>(types.Where(type =>
                type.GetAttributes().Any(ad =>
                ad.AttributeClass?.ToDisplayString() == "Plugin.Maui.SmartNavigation.Attributes.IgnoreAttribute")
                || type.IsAbstract), comparer);

            var singletons = types.Where(type =>
                    type.GetAttributes().Any(ad =>
                    ad.AttributeClass?.ToDisplayString() == "Plugin.Maui.SmartNavigation.Attributes.SingletonAttribute"));
            dependencies["ExplicitSingletons"] = new HashSet<ITypeSymbol>(singletons, comparer);

            var transients = types.Where(type =>
                type.GetAttributes().Any(ad =>
                ad.AttributeClass?.ToDisplayString() == "Plugin.Maui.SmartNavigation.Attributes.TransientAttribute"));
            dependencies["ExplicitTransients"] = new HashSet<ITypeSymbol>(transients, comparer);

            var pages = types.Where(t => t.TypeKind == TypeKind.Class && t.Name.EndsWith("Page") && !ignoredTypes.Contains(t, comparer));
            dependencies["Pages"] = new HashSet<ITypeSymbol>(pages, comparer);

            var viewModels = types.Where(t => t.TypeKind == TypeKind.Class && t.Name.EndsWith("ViewModel") && !ignoredTypes.Contains(t, comparer));
            dependencies["ViewModels"] = new HashSet<ITypeSymbol>(viewModels, comparer);

            var services = types.Where(t => t.TypeKind == TypeKind.Class && t.Name.EndsWith("Service") && !ignoredTypes.Contains(t, comparer));
            dependencies["Services"] = new HashSet<ITypeSymbol>(services, comparer);

            var abstractions = types.Where(t => t.TypeKind == TypeKind.Interface && t.Name.EndsWith("Service"));
            dependencies["Abstractions"] = new HashSet<ITypeSymbol>(abstractions, comparer);

            Log.WriteLine($"Found {pages.Count()} pages.");
            Log.WriteLine($"Found {viewModels.Count()} ViewModels.");
            Log.WriteLine($"Found {services.Count()} Services.");
            Log.WriteLine($"Found {abstractions.Count()} interfaces.");

            return dependencies;
        }

        private Dictionary<ITypeSymbol, ITypeSymbol> GetPageToViewModelMappings(Dictionary<string, HashSet<ITypeSymbol>> dependencies)
        {
            var VMLookup = new Dictionary<ITypeSymbol, ITypeSymbol>(SymbolEqualityComparer.Default);

            foreach (var page in dependencies["Pages"])
            {
                var matches = dependencies["ViewModels"].Where(vm =>
                               vm.Name == $"{page.Name}ViewModel" || vm.Name == page.Name.Substring(0, page.Name.Length - 4) + "ViewModel").ToList();

                if (matches.Count == 1)
                {
                    var pageType = page.Name;
                    var vmType = matches[0].Name;

                    Log.WriteLine($"[AutoDependencies Source Generator] adding mapping for {pageType} to {vmType}");

                    VMLookup.Add(page, matches[0]);
                }
            }

            return VMLookup;
        }

        private static IEnumerable<ITypeSymbol> GetAllTypes(INamespaceSymbol root)
        {
            foreach (var namespaceOrTypeSymbol in root.GetMembers())
            {
                if (namespaceOrTypeSymbol is INamespaceSymbol @namespace)
                    foreach (var nested in GetAllTypes(@namespace))
                        yield return nested;

                else if (namespaceOrTypeSymbol is ITypeSymbol type)
                    yield return type;
            }
        }
    }
}
